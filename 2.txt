
마크다운이 표준이 없어서 사용하는 곳마다 조금씩 다르다.


구조로 구분하기도 하고, 메모리 연속성으로 구분하기도 함..

집어넣은 순서대로 저장되는 것을 시퀀스 컨테이너 ( 벡터, 리스트, 스트링, 디큐 등등) 


연관 컨테이너는 연속적이지 않다.
무조건 메모리가 떨어진 건 아니다. 바이너리 트리를 연속적인 메모리로 구성할 수도 있다.

곱하기 2 더하기 1로 자식을 따라갈 수있다.
(우선순위 큐)
R S1 S2 SS11 SS12 SS12 SS

따라서 메모리 연속성으로 구분하는게 아니라  구조적  연속성으로 구분



메모리로 구분하는 경우
array 는 연속적인 메모리

linked list 

연속적인 메모리는 한번에 접근 할 수 있다(랜덤 엑세스 : 시작 점 +)

링크스 리스트 한번에 접근 불가(따라 가야한다.)


배열
벡터
큐
스택
우선순위큐
데큐
리스트
맵

배열 : 적은 자료에 유리, 크기 변경 불가
벡터 : 크기를 변경할 수 있음, 메모리 복사 해야 하기 때문에 느릴수 있다. 검색이 느림(정렬이 되어 있지 않기 때문에..)

링크드 리스트 : 중간에 삽입삭제 편리, 랜덤 엑에스 불가

맵 : 가장 좋은 것 같다.. 데이터가 크면 균형을 잡고 비교를 하기 때문에 인서트와 딜리트가 느림, 데이터 양이 적으면 배열이 더 빠를 수 있다.

해시 테이블 (unordered ~~) : 해시 기반 구조, 수학적으로 해시함수를 만들어서 계산과정을 줄일 수 있다. big O 표기법으로는 상수값이 나오도록 할 수도 있다. 데이터가 골고루 분산 되어야 한다. ( 모든 테이블이 같은 곳에 몰려있으면 하나 마나하다.) 데이터의 수학점 어려움이 있다.

내가 사용하는 데이터와 양에 따라서 맞는 자료구조를 사용해야 한다.


https://programmers.co.kr/learn/courses/30/lessons/42579
베스트 앨범 문제 
map 사용해서 해결...
map을 사용 안해도 되는데, 이해하는 데 구조적으로 풀었다. (다른 사람이 보기에도 좋다. 효율성에서도 훨씬 좋다)

람다표현식 ( 펑셔널 프로그래밍)



https://programmers.co.kr/learn/courses/30/lessons/42585
