


C++

multi-paradigm 언어
- C의 확장 , 옛날에는 C위드 클래스였음
- 객체지향
- 제네릭 프로그래밍(템플릿, 최근에 펑셔널 프로그래밍도 추가 됨)

추가 된 키워드 : 객체지향 확장과 제네릭프로그래밍을 위해서.. 함수형 프로그래밍을 위해서도 확장 됨

inline, 등등

C에서 확장 됐다고 생각하는 이유
기계어 -> 어셈블리어 - > 절차지향 -> 객체지향 언어

기능 별로 나누기 위해서 폴더와 디렉토리가 나왔다.
디렉토리 : C나 파이썬에서는 모듈 단위가 되고, 자바에서는 팩킷단위가 된다.

객체지향
사람이 생각하는 방식과 비슷
분리, 추상화, 재활용
상속, 다형성, 은닉성

pie
다형성
상속
은닉성



클래스랑 구조체의 차이점
구조체는 기본이 퍼블릭이고, 함수도 갖고 다 가지고 있다.

객체화
클래스는 기본이 프라이빗임, -> 은닉성(필요한 것만 보여주는 것) -> 추상화


은닉성
원하지 않는 부분은 외부에 숨길 수 있다.
데이터가 변경이 안되면, 다른 객체를 만들어도 변경없이사용할 수있다

상속성
코드 재활용,
인터페이스 상속 : 사용하는 방법을 사용
구현 상속 : 사용하는 방법의 디테일한 구현까지 상속하는 것 (자바는 아예 구현 상속을 못 받도록 막혀있음, C++은 구현상속이나 인터페이스 상속이나 같게 취급함... 자바에서는 extends로 구현상속 , implements로 인터페이스 상속, C++에서는 구현상속 지양해야함)

다형성
같아보이지만 실제로는 다른 성격을 같는 것..
override : 
상속 받으면 부모처럼 입력해도 동작은 자식처럼 한다.

virtual이 된 얘들만 오버라이드 된다.

void printName() {
}
virtual void printRealName () {
}


CShape* pS = &s;
pS-printName();
pS-printRealName();

pS = &r;
pS-printName();			//shape
pS-printRealName();		//rect


//==========

CShape* pSs[3] = {&s, &r, &t};

for(CShape* pS : pSs)
{
	pS-printName();		//똑같아 보이지만
	pS-printRealName();	//다른 기능을 한다.
}


(논외) 자바는 기본적으로 virtual이라도 다 붙어있는 것과 같다.C++는 꼭 virtual이라고 넣어줘야만 오버라이드 된다.


overload : 이름이 같아도 파라미터에 따라서 알아서 맞는 함수를 호출 하는 경우

연산자 오버로딩 : 

this 포인터로 쓰일 때, 멤버 접근할 때 알아보기

class k 
{
	int m;
	k operator+ (const k b) {
		this->m += b.m
		return this;
	}
}



STL : 스탠다드 탬플릿 라이브러리(어떤 개념으로 만들어졌구나, 어떤 기능인지.. 어떤 것들이 있었던 것 같은 느낌만 있으면 된다. 개념적인 것들만 머리 속에 넣어놓고 필요할 때마다 찾아쓴다.)

컨테이너
알고리즘
이터레이터(반복자) : 컨테이너마다 다음 데이터로 접근하는 방식에 따라서 다 달라서 알아야 하는데, 이터레이터가 각각 알 필요가 없게 해준다.

자바 JDBC, C ODBC : Oracle, mySQL, SQLite,Real~ 등등이 있는 데, 이 표준을 지원하게 되면 간단하게 사용할 수 있게 해준다. (이터레이터는 이와 비슷한 개념이다.)

등등(스레드, 스마트 ~, 레귤~ )

함수객체
()를 오버로딩
함수처럼 보이는 객체


tcpschool.com/cpp/intro 에 좋은 정보 많다

알고리즘
읽기 알고리즘
find([반복자]에서부터,  )
for_each([~에서 부터], [~까지], [함수 or 람다])

변경 알고리즘
copy()
swap()
transfrom()	<- map이랑 관련

수치 알고리즘
accumulate() ~에서 부터, ~까지, ~을 하면서

함수형 프로그래밍 (11부터 지원하고 있다, 요즘 언어들은 전부 함수형 프로그래밍을 지원함)
-부작용을 없애기 위한 (위한 노력하는) 프로그래밍
 - 순수함수를 지향 (부작용이 없고, 입력이 같으면 항상출력이 보장되는 함수)
 - 순수함수의 조합으로 프로그래밍을 지향
 - Mutable 데이터를 지양 (immutable 지향)
 - 함수를 1급 객체로, 고차함수로 재사용성 지향 ( 이전에는 데이터 취급을 받지 못하고, 코드 취급함, 하지만 함수형 프로그래밍에선 함수를 데이터로 취급하면 함수를 파라미터로 받거나 리턴 받을 수 있게 해준다.)
 - 1급객체
 - 고차함수 (함수를 인자로 받거나 리턴)
 - 람다 (익명 함수 표현식, 함수는 이제껏 식이 아니라 문이었다. 하지만 람다는 이것을 식으로 만든다.(람다표기법은 언어마다 조금씩 다르다) 

[]( 파라미터(없으면 생략 될 수도 있다) )-> 리턴타입 { 함수내용 }

[]는 밖에서 사용되는 변수를 함수 안에서 사용하고 싶을 때(캡쳐) [] 안에 넣어준다
[=a] a의 값을 복사 해서 사용한다.
[&a] a의 메모리를 가져와서 사용한다.
[&] 은 알아서 {}함수 표현 부분에서 알아서 메모리로 가져온다. (하지만 은닉성을 해치므로 사용하지 지양하는 것이 좋다)

람다 표현식은 변수로 받을 수도 있다. 데이터 취급하므로
auto a = (람다 표현식)

람다 받는 방법
1. functor< >에 담는 방법
2. 함수 포인터에 담는 방법
3. auto 컴파일러가 알아서 담아 준다. (오토로 쓸 수 있으면 오토로 쓰는 것이 좋다. 펑터로 사용하면 <> 안에 부분을 수정해야 한다.)


 - 클로저 : 람다가 동작하기 위해서 필요한 환경(변수..)를  ??
	캡처를 해가지고 환경가까지.. ?? 
(클로저 때문에 가비지 컬렉터가 있는 언어와 비슷해진다. 스마트 포인터(STL에 있는)를 활용하면, 메모리 레퍼런스 카운트가 0인 얘들을 자동으로 지워준다.)

//==========

디버깅 실력이 좋아야 한다.